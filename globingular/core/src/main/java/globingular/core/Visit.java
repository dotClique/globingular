package globingular.core;

import java.time.LocalDate;

/**
 * <p>
 * Visit class contains the necessary metadata about a specific visit to a
 * country.
 * </p>
 * 
 * <p>
 * An instance of the Visit class contains:
 * <ul>
 * <li>Methods for retrieving info about which country was visited and
 * when</li>
 * </ul>
 * </p>
 */
public class Visit {

    /**
     * The country this visit was to.
     */
    private final Country country;

    /**
     * The time of arrival in the country.
     */
    private final LocalDate arrival;

    /**
     * The time of departure from the country.
     */
    private final LocalDate departure;

    /**
     * Initiate a new visit to the given country at the given time.
     *  @param country   The country that has been visited
     * @param arrival   The arrival time to log in the visit
     * @param departure The departure time to log in the visit
     */
    public Visit(final Country country, final LocalDate arrival, final LocalDate departure) {
        this.country = country;
        this.arrival = arrival;
        this.departure = departure;
        if (!isValidDateInterval(arrival, departure)) {
            throw new IllegalArgumentException(
                    "Both arrival and departure must be null, or arrival must not come before departure!");
        }
    }

    /**
     * Retrieve the country this visit-object details.
     * 
     * @return The country that has been visited
     */
    public Country getCountry() {
        return this.country;
    }

    /**
     * Retrieve the date and time of arrival to the country.
     * 
     * @return A LocalDate of the arrival in the country
     */
    public LocalDate getArrival() {
        return this.arrival;
    }

    /**
     * Retrieve the date and time of departure from the country.
     * 
     * @return A LocalDate of the departure from the country
     */
    public LocalDate getDeparture() {
        return this.departure;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
        return String.format("[%s at %s - %s]", this.country.getShortName(), this.arrival, this.departure);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
        // This is auto-generated by VS Code
        final int prime = 31;
        int result = 1;
        result = prime * result + ((arrival == null) ? 0 : arrival.hashCode());
        result = prime * result + ((country == null) ? 0 : country.hashCode());
        result = prime * result + ((departure == null) ? 0 : departure.hashCode());
        return result;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean equals(final Object obj) {
        // This is auto-generated by VS Code
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        Visit other = (Visit) obj;
        if (arrival == null) {
            if (other.arrival != null) {
                return false;
            }
        } else if (!arrival.equals(other.arrival)) {
            return false;
        }
        if (country == null) {
            if (other.country != null) {
                return false;
            }
        } else if (!country.equals(other.country)) {
            return false;
        }
        if (departure == null) {
            if (other.departure != null) {
                return false;
            }
        } else if (!departure.equals(other.departure)) {
            return false;
        }
        return true;
    }

    /**
     * Create a new Visit using corresponding {@link Country}-instance from the given {@link World}.
     * 
     * @param visit The visit to use as basis for the new one
     * @param world The world to retrieve the new country from
     * @return      A Visit with the correct Country-instance from the given World.
     *              Returns {@code null} if the country doesn't exist in the given World.
     */
    public static Visit newVisitFromWorld(final Visit visit, final World world) {
        // Retrieve a valid Country from the given World
        Country country = world.getCountryFromCode(visit.getCountry().getCountryCode());
        if (country == null) {
            // If a Country-instance is not found, it means the countryCode was invalid for this World
            return null;
        }
        // Create a new Visit with the correct Country-instance
        return new Visit(country, visit.getArrival(), visit.getDeparture());
    }

    /**
     * Check whether the given date-interval is valid for construction of a Visit.
     * @param arrival Arrival-time.
     * @param departure Departure-time.
     * @return Whether the date-interval is valid.
     */
    public static boolean isValidDateInterval(final LocalDate arrival, final LocalDate departure) {
        return (arrival != null && departure != null && !departure.isBefore(arrival))
                || (arrival == null && departure == null);
    }
}
